using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Gtk;
using Path = System.IO.Path;

namespace Composition.Model;

public class SequenceTreeStore: TreeStore
{
    private readonly Dictionary<string, TreeIter> _filePathToIter = new();

    public SequenceTreeStore(): base(typeof(string), typeof(string), typeof(Sequence), typeof(bool))
    {
        
    }

    public bool UnloadFile(string filePath)
    {
        bool containsKey = _filePathToIter.ContainsKey(filePath);
        if (containsKey)
        {
            TreeIter iter = _filePathToIter[filePath];
            Remove(ref iter);
        }
        return containsKey;
    }
    
    public void LoadFile(string filePath)
    {
        bool isFolder(string path) => File.GetAttributes(path).HasFlag(FileAttributes.Directory);
        
        Console.WriteLine(Localization.Load_File_Message, (isFolder(filePath) ? "folder" : "file"), filePath);
        if (isFolder(filePath))
        {
            var files = Directory.GetFiles(filePath);
            foreach (string file in files)
            {
                if (file.EndsWith(".compose") || isFolder(file))
                {
                    LoadFile(file);
                }
                else
                {
                    Console.WriteLine(Localization.Skip_File_Message, (isFolder(file) ? "folder" : "file"), file);
                }
            }
        }
        else
        {
            UnloadFile(filePath);

            List<Sequence> sequences = FileParser.Parse(filePath);

            string name = Path.GetFileName(filePath);
            name = Regex.Replace(name, @"\.compose$", "", RegexOptions.IgnoreCase);
            TreeIter fileIter = AppendValues(name, "", true);
            _filePathToIter[filePath] = fileIter;
        
            foreach (Sequence sequence in sequences)
            {
                string keysyms = string
                    .Join(" + ", sequence.Keys.Select(key => key.ToString()))
                    .Replace("Multi_key", "âŽ„");
                string character = sequence.Character;
                TreeIter sequenceIter = AppendValues(fileIter, keysyms, character, sequence, true);
            }
        }
    }

    public Dictionary<string, List<Sequence>> GetEnabledSequences()
    {
        var sequences = new Dictionary<string, List<Sequence>>();
        TreeIter iter;
        if (GetIterFirst(out iter))
        {
            do
            {
                string filePath = (string) GetValue(iter, 0);
                bool fileEnabled = (bool) GetValue(iter, 3);
                sequences[filePath] = new List<Sequence>();
                TreeIter childIter;
                if (fileEnabled && IterChildren(out childIter, iter))
                {
                    do
                    {
                        Sequence sequence = (Sequence) GetValue(childIter, 2);
                        bool sequenceEnabled = (bool) GetValue(childIter, 3);
                        if (sequenceEnabled)
                        {
                            sequences[filePath].Add(sequence);
                        }
                    } while (IterNext(ref childIter));
                }
            } while (IterNext(ref iter));
        }
        return sequences;
    }
    
    public void SaveFile(string filePath)
    {
        string content = Serialize();
        File.WriteAllText(filePath, content);
    }

    public string Serialize()
    {
        Dictionary<string, List<Sequence>> sequences = GetEnabledSequences();
        
        var sb = new StringBuilder();
        sb.AppendLine("# XCompose file generated by Composition");
        sb.AppendLine("include \"%L\"");
        sb.AppendLine("");

        foreach (string filePath in sequences.Keys)
        {
            if (sequences[filePath].Count > 0)
            {
                string fileName = Path.GetFileName(filePath);
                int leftMinWidth = sequences[filePath].Max(sequence => sequence.GetLeftMinWidth());
                sb.AppendLine($"# {fileName}");
                foreach (Sequence sequence in sequences[filePath])
                {
                    sb.AppendLine(sequence.Serialize(leftMinWidth));
                }
                sb.AppendLine("");
            }
        }

        return sb.ToString();
    }
}